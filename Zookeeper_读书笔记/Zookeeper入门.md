#### 1.Zookeeper中的基本数据模型单元——znode节点
```
1).Zookeeper通过操作和维护一些小型的数据节点，这些节点被称为znode,采用类似于文件系统的层级树状结构来对数据进行管理。
2).znode节点可能含有数据，也可能没有。如果一个znode节点包含任何数据，那么数据存储为字节数组(byte array).字节数组的具体格式
   特定于每个应用的实现，Zookeeper并不直接提供解析的支持。
3).需要注意的是，Zookeeper并不允许局部写入或读取znode节点的数据。当设置一个znode节点的数据或读取时，znode节点的内容会被整个
   替换或全部读取进来。
```

#### 2.znode节点的类型
当新建znode时，还需要指定该节点的类型(mode)，不同的类型决定了znode节点的行为方式。
* znode节点可以是**持久(persistent)节点**，还可以是**临时(ephemeral)节点**。持久的znode节点，只能通过调用delete来进行删除。临时的znode与之
相反，当创建该节点的客户端崩溃或关闭了与Zookeeper的连接时，这个节点就会被删除。
* 持久znode是一种非常有用的znode，可以通过持久类型的znode为应用保存一些数据，即使znode的创建者不再属于应用系统时，数据也可以保存下来
而不丢失。
* 临时znode传达了应用某些方面的信息，仅当创建者的会话有效时这些信息必须有效保存。一个临时znode节点，在以下两种情况下将被删除：
```
1.当创建该会话的客户端的会话因超时或主动关闭而终止时。
2.当某个客户端(不一定是创建者)主动删除该节点时。
```
* 因为临时的znode在其创建者的会话过期时被删除，所以我们现在不允许临时节点拥有子节点。在社区的讨论中，已经讨论过关于允许临时znode拥有子节点
的问题，其想法是使其子节点也均为临时节点。这个功能也许会出现在未来的发布版本中，但现在还是不可用的。
* 一个znode还可以设置为**有序(sequential)节点**。一个有序znode节点被分配**唯一一个单调递增**的整数。当创建有序节点时，一个序号会被追加到
路径之后。例如，如果一个客户端创建了一个有序znode节点，其路径为/task/task-，那么Zookeeper将会分配一个序号，如1，并将这个数字追加到路径之
后，最后该znode节点为/task/task-1。Zookeeper通过有序znode提供了创建具有唯一名称的znode的简单方式。同时也通过这种方式可以直观地查看znode
的创建顺序。
* 总之，znode一共有4种类型：持久的、临时的、持久有序的(persistent_sequential)和临时有序的(ephemeral_sequential)。

#### 3.znode数据的获取——监视与通知
* 客户端获取znode数据是基于通知(notification)的机制：客户端向Zookeeper注册需要接受通知的znode，通过对znode设置**监视点**(watch)来接受通知。
监视点是一个单次触发的操作，亦即**每个监视点只会触发一个通知**。为了接收多个通知，客户端必须在每次通知后设置一个新的监视点。
* 通知机制的一个重要保障是，对同一个znode的操作，**先向客户端传递通知，然后再对该节点进行变更**。如果客户端对一个znode设置了监视点，而该
znode发生了两个连续更新。第一次更新后，客户端在观察第二次变化前就接收到了通知，然后读取znode中的数据。我们认为主要特性在于通知机制阻止了客
户端所观察的更新顺序。虽然Zookeeper的状态变化传播给某些客户端时更慢，但我们保障客户端以全局的顺序来观察Zookeeper的状态。
* Zookeeper可以定义不同类型的通知，这依赖于设置监视点对应的通知类型。客户端可以设置多种监视点，如**监控znode的数据变化、监控子节点的变化、**
**监控znode的创建或删除** 。为了设置监视点，可以使用任何API中的调用来读取Zookeeper的状态，在调用这些API时，传入一个watcher或使用默认的watcher。

#### 4.znode的版本
每一个znode都有一个版本号，它随着每次数据变化而自增。两个API操作可以有条件地执行：setData 和 delete。这两个调用可以传入版本号参数，只有当
传入的版本号参数与服务器上的版本号一致时调用才会成功。当多个Zookeeper客户端对同一个znode进行操作时，版本的使用就会显得尤为重要。Zookeeper
通过使用版本来阻止并行操作的不一致性。

#### 5.Zookeeper服务器的运行模式
Zookeeper服务器端运行于两种模式下：独立模式(standalone)和仲裁模式(quorum)。独立模式几乎与其术语所描述的一样：有一个单独的服务器，Zookeeper
状态无法复制。在仲裁模式下，具有一组Zookeeper服务器，我们称为Zookeeper集合(Zookeeper ensemble)，它们之间可以进行状态的复制，并同时服务于
客户端的请求。从这个角度出发，我们使用术语“Zookeeper 集合”来表示一个服务器设施，这一设施可以由独立模式的一个服务器组成，也可以由仲裁模式下
的多个服务器组成。

#### 6.会话
* 在对一个Zookeeper集合执行任何请求前，一个客户端必须先与服务建立会话。客户端提交给Zookeeper的所有操作均关联在一个会话上。当一个会话因某种
原因而终止时，在这个会话期间创建的临时节点将会消失。
* 当客户端初始连接到集合中某一个服务器或一个独立的服务器。客户端通过TCP协议与服务器进行连接并通信，但当会话无法与当前连接的服务器继续通信时，
会话就可能转移到另一个服务器上。Zookeeper客户端库透明地转移一个会话到不同的服务器。
* 会话提供了顺序保障，这就意味着同一个会话中的请求会以FIFO(先进先出)顺序执行。通常，一个客户端只打开一个会话，因此客户端请求将全部以FIFO
顺序执行。如果客户端拥有多个并发会话，FIFO顺序在多个会话之间不保证保持。而即使一个客户端中连贯的会话并不重叠，也未必能够保证FIFO顺序。

#### 7.会话的状态和生命周期
* 会话的生命周期(lifetime)是指会话从创建到结束的时期，无论会话正常关闭还是因超时而导致过期。
* Zookeeper会话的状态分为：CONNECTING、CONNECTED、CLOSED 和 NOT_CONNECTED。

#### 8.会话的超时参数
创建一个会话时，你需要设置会话超时这个重要的参数，这个参数设置了Zookeeper服务允许会话被声明为超时之前存在的时间。如果经过时间 t 之后
服务接收不到这个会话的任何消息，服务就会声明会话过期。而在客户端侧，如果经过 t/3 的时间未收到任何消息，客户端将向服务器发送心跳消息。
在经过 2t/3 的时间后，Zookeeper客户端开始寻找其他的服务器，而此时它还有 t/3 的时间去寻找。</br>

#### 9.发生网络分区时的会话状态
如果一个客户端与服务器因超时而断开连接，客户端仍然保持 CONNECTING 状态。如果因网络分区问题导致客户端与Zookeeper集合被隔离而发生连接断开，
那么其状态将会一直保持，直到显式地关闭这个会话，或者分区问题修复后，客户端能够获悉Zookeeper服务器发送的会话已经过期。发生这种行为是因为
**Zookeeper集合对声明会话超时负责，而不是客户端负责。** 直到客户端获悉Zookeeper会话过期，否则客户端不能声明自己的会话过期。然而，客户端
可以选择关闭会话。

#### 10.客户端尝试连接
当客户端尝试连接到一个不同的服务器时，非常重要的是，这个服务器的状态要与最后连接的服务器的状态保持最新。客户端不能连接到这样的服务器：它未
发现而客户端却已经发现的更新。Zookeeper通过在服务中排序更新操作来决定状态是否最新。Zookeeper确保每一个变化相对于所有其他已执行的更新是
完全有序的。因此，如果一个客户端在位置 i 观察到一个更新，它就不能连接到只观察到 i' < i 的服务器上。在Zookeeper实现中，系统根据每一个更新
建立的顺序来分配给**事务标识符**。



















